#!/usr/bin/python3.7
import asyncio
import json
from datetime import datetime, timedelta
from sys import exit
import logging

from tornado.ioloop import IOLoop
import tornado.web
from tornado.httpserver import HTTPServer
from tornado.web import RequestHandler
from tornado import escape

from metrolinkTimes.tfgmMetrolinksAPI import TFGMMetrolinksAPI
from metrolinkTimes.tramGraph import TramGraph

logging.basicConfig(filename='/var/log/metrolinkTimes/metrolinkTimes.log',
                    format='%(asctime)s %(levelname)s %(pathname)s %(lineno)s '
                           '%(message)s',
                    level=logging.ERROR)


def dt_handler(obj):
    if isinstance(obj, datetime):
        return obj.isoformat()
    elif isinstance(obj, timedelta):
        return obj.total_seconds()

    raise TypeError


def json_encode(value):
    return json.dumps(
        value,
        ensure_ascii=False,
        indent=2,
        sort_keys=True,
        default=dt_handler)


escape.json_encode = json_encode


class GraphUpdater:
    def __init__(self, graph):
        self.api = TFGMMetrolinksAPI()
        self.graph = graph
        self.stationMappings = {
            "Ashton-under-Lyne": "Ashton-Under-Lyne",
            "Deansgate Castlefield": "Deansgate - Castlefield",
            "Deansgate": "Deansgate - Castlefield",
            "Ashton": "Ashton-Under-Lyne",
            "MCUK": "MediaCityUK",
            "Newton Heath": "Newton Heath and Moston",
            "Victoria Millgate Siding": "Victoria",
            "Rochdale Stn": "Rochdale Railway Station"
        }

    def update(self):
        data = self.api.getData()

        if data is None:
            # Internet down?
            return

        tramsVia = []

        for station in data:
            for platform in data[station]:
                nodeID = "{}_{}".format(station, platform)
                if nodeID not in self.graph.getNodes():
                    logging.error("ERROR: Unknonw platfrom {}".format(nodeID))
                    continue

                pidTramData = []
                message = None
                updateTime = None

                apiPID = data[station][platform][0]
                if not (apiPID["MessageBoard"].startswith("^F0")
                        or (apiPID["MessageBoard"] == "<no message>")):
                    message = apiPID["MessageBoard"]

                # This seems to be how flashing is encoded. We'll get rid of it
                if message is not None:
                    message = message.replace("^$", "")

                updateTime = datetime.strptime(
                    apiPID["LastUpdated"],
                    "%Y-%m-%dT%H:%M:%SZ")

                if self.graph.getLastUpdateTime(nodeID) == updateTime:
                    return

                for i in range(4):
                    if apiPID["Dest{}".format(i)] != "":
                        stationName = apiPID["Dest{}".format(i)]
                        # TODO: Shift this & station mappings to tramGraph
                        validDests = (list(self.graph.getStations())
                                      + [
                                            "Terminates Here",
                                            "See Tram Front",
                                            "Not in Service"])
                        viaName = None

                        if " via " in stationName:
                            splitName = stationName.split(" via ")
                            stationName = splitName[0]
                            viaName = splitName[1]
                        if stationName in self.stationMappings:
                            stationName = self.stationMappings[stationName]
                        if viaName in self.stationMappings:
                            viaName = self.stationMappings[viaName]
                            if viaName not in tramsVia:
                                tramsVia.append(viaName)
                        if stationName not in validDests:
                            logging.error(
                                "Unknown station {}".format(stationName))
                            continue
                        if (viaName is not None) and (
                          viaName not in validDests):
                            logging.error("Unknown station {}".format(viaName))
                            viaName = None

                        pidTramData.append({
                            "dest": stationName,
                            "via": viaName,
                            "carriages": apiPID["Carriages{}".format(i)],
                            "status": apiPID["Status{}".format(i)],
                            "wait": int(apiPID["Wait{}".format(i)])
                        })

                self.graph.updatePlatformPID(
                    nodeID,
                    pidTramData,
                    message,
                    updateTime)

        self.graph.decodePIDs()
        self.graph.clearOldDeparted()
        self.graph.locateDepartingTrams()
        self.graph.locateTramsAt()
        self.graph.clearNodePredictions()

        # We need to predict trams at definitively known locations first
        # so we can use these predictions to verify if trams are actually
        # starting at other stops
        self.graph.predictTramTimes(["tramsHere", "tramsDeparted"])

        self.graph.debounceNew()

        self.graph.gatherTramPredictions(["tramsHere", "tramsDeparted"])

        self.graph.locateApproachingTrams()
        self.graph.predictTramTimes(["tramsApproaching"])
        self.graph.gatherTramPredictions(["tramsApproaching"])
        self.graph.locateApproachingTrams()

        self.graph.clearNodePredictions()
        self.graph.gatherTramPredictions(["tramsHere",
                                          "tramsDeparted",
                                          "tramsApproaching"])

        # This might not be needed. Could just look like doubling up because of
        # routes being run on day of testing
        self.graph.finalisePredictions()

        tramsAts = self.graph.getTramsAts()
        tramsAt = 0

        tramsDeparteds = self.graph.getTramsDeparteds()
        tramsDeparted = 0

        tramsStartings = self.graph.getTramsStarting()
        tramsStarting = 0
        platformsStarting = 0
        stationsStarting = set()

        for node in tramsAts:
            tramsAt = tramsAt + len(tramsAts[node])

        for node in tramsDeparteds:
            tramsDeparted = tramsDeparted + len(tramsDeparteds[node])

        for node in tramsStartings:
            tramsStarting = tramsStarting + len(tramsStartings[node])
            if len(tramsStartings[node]):
                platformsStarting += 1
                stationsStarting.add(self.graph.DG.nodes[node]["stationName"])

        logging.info("Len nodes without average: {}".format(
            len(self.graph.nodesNoAvDwell())))
        logging.info("Len edges without average: {}".format(
            len(self.graph.edgesNoAvTrans())))
        logging.info("trams at stations: {}".format(tramsAt))
        logging.info("trams departed stations: {}".format(tramsDeparted))
        logging.info("trams yet to start at stations: {}".format(
            tramsStarting))
        logging.info("platforms with trams starting: {}/{}".format(
            platformsStarting,
            len(self.graph.getNodes())))
        logging.info("stations with trams starting ({}/{}): {}".format(
            len(stationsStarting),
            len(self.graph.getStations()),
            stationsStarting))
        logging.info("trams are going via {}".format(tramsVia))

    async def updateLoop(self):
        while True:
            self.update()
            await asyncio.sleep(1)


class BaseHandler(RequestHandler):
    def set_default_headers(self, *args, **kwargs):
        origin = "*"
        with open("/etc/metrolinkTimes/metrolinkTimes.conf") as conf_file:
            origin = json.load(conf_file)["Access-Control-Allow-Origin"]
        self.set_header("Access-Control-Allow-Origin", origin)
        self.set_header("Access-Control-Allow-Headers", "x-requested-with")
        self.set_header("Access-Control-Allow-Methods", "GET, OPTIONS")


class MainHandler(BaseHandler):
    def get(self):
        self.write({"paths": [
            "debug/",
            "health/",
            "station/"
        ]})


class DebugHandler(BaseHandler):
    def get(self):
        here = graph.getTramsHeres()
        dep = graph.getTramsDeparteds()
        start = graph.getTramsStarting()
        ret = {
            "missingAverages": {
                "platforms": graph.nodesNoAvDwell(),
                "edges": graph.edgesNoAvTrans()
            },
            "trams": {
                "here": {k: here[k] for k in here if here[k] != []},
                "departed": {k: dep[k] for k in dep if dep[k] != []},
                "starting": {k: start[k] for k in start if start[k] != []}
            }
        }

        self.write(ret)


class StationHandler(BaseHandler):
    def get(self):
        ret = ["{}/".format(station) for station in graph.getStations()]
        self.write({"stations": ret})


class StationNameHandler(BaseHandler):
    def get(self, stationName):
        def getArg(name, default):
            arg = self.get_query_arguments(name)
            if arg == []:
                arg = default
            else:
                arg = arg[0]

            return arg

        if stationName not in graph.getStations():
            raise tornado.web.HTTPError(404)

        ret = {}

        if getArg("verbose", "false").lower() != "true":
            ret["platforms"] = [
                "{}/".format(platID) for platID in graph.getStationPlatforms(
                    stationName)]
        else:
            ret["platforms"] = {}
            for platID in graph.getStationPlatforms(stationName):
                nodeID = "{}_{}".format(stationName, platID)
                ret["platforms"][platID] = {
                    "updateTime": graph.getLastUpdateTime(nodeID),
                }

                if getArg("predictions", "true").lower() == "true":
                    predictions = graph.getNodePredictions()[nodeID]
                    if getArg("tramPredictions", "true").lower() == "false":
                        for tram in predictions:
                            del(tram["predictions"])
                    ret["platforms"][platID]["predictions"] = predictions
                    ret["platforms"][platID]["here"] = graph.getTramsHeres()[
                        nodeID]

                if getArg("message", "true").lower() == "true":
                    ret["platforms"][platID]["message"] = graph.getMessage(
                        nodeID)

                if getArg("meta", "false").lower() == "true":
                    dwellTimes = graph.getDwellTimes()[nodeID]
                    averageDwell = timedelta()
                    for dwellTime in dwellTimes:
                        averageDwell = averageDwell + dwellTime
                    if len(dwellTimes) > 0:
                        averageDwell = averageDwell/len(dwellTimes)
                    else:
                        averageDwell = None

                    pred = {}
                    for pNodeID in graph.getNodePreds(nodeID):
                        pred[pNodeID] = {
                            "transitTimes": graph.getTransit(pNodeID, nodeID)
                            }

                        (pred[pNodeID]["averageTransitTime"],
                            isDirectAverage) = graph.getAverageTransit(
                                pNodeID,
                                nodeID)

                    ret["platforms"][platID]["mapPos"] = {
                        "x": graph.getMapPos(nodeID)[0],
                        "y": graph.getMapPos(nodeID)[1]
                        }
                    ret["platforms"][platID]["dwellTimes"] = dwellTimes
                    ret["platforms"][platID]["averageDwellTime"] = averageDwell
                    ret["platforms"][platID]["predecessors"] = pred

            if getArg("departed", "false").lower() == "true":
                ret["platforms"][platID]["departed"] = (
                    graph.getTramsDeparteds()[nodeID])

        self.write(ret)


class StationNamePlatHandler(BaseHandler):
    def get(self, stationName, platID):
        def getArg(name, default):
            arg = self.get_query_arguments(name)
            if arg == []:
                arg = default
            else:
                arg = arg[0]

            return arg

        nodeID = "{}_{}".format(stationName, platID)
        if nodeID not in graph.getNodes():
            raise tornado.web.HTTPError(404)

        ret = {
            "updateTime": graph.getLastUpdateTime(nodeID),
        }

        if getArg("predictions", "true").lower() == "true":
            predictions = graph.getNodePredictions()[nodeID]
            if getArg("tramPredictions", "true").lower() == "false":
                for tram in predictions:
                    del(tram["predictions"])
            ret["predictions"] = predictions
            ret["here"] = graph.getTramsHeres()[nodeID]

        if getArg("message", "true").lower() == "true":
            ret["message"] = graph.getMessage(nodeID)

        if getArg("meta", "false").lower() == "true":
            dwellTimes = graph.getDwellTimes()[nodeID]
            averageDwell = timedelta()
            for dwellTime in dwellTimes:
                averageDwell = averageDwell + dwellTime
            if len(dwellTimes) > 0:
                averageDwell = averageDwell/len(dwellTimes)
            else:
                averageDwell = None

            pred = {}
            for pNodeID in graph.getNodePreds(nodeID):
                pred[pNodeID] = {
                    "transitTimes": graph.getTransit(pNodeID, nodeID)
                    }

                (pred[pNodeID]["averageTransitTime"],
                    isDirectAverage) = graph.getAverageTransit(pNodeID, nodeID)

            ret["mapPos"] = {
                "x": graph.getMapPos(nodeID)[0],
                "y": graph.getMapPos(nodeID)[1]
                }
            ret["dwellTimes"] = dwellTimes
            ret["averageDwellTime"] = averageDwell
            ret["predecessors"] = pred

        if getArg("departed", "false").lower() == "true":
            ret["departed"] = graph.getTramsDeparteds()[nodeID]

        self.write(ret)


class HealthHandler(BaseHandler):
    def get(self):
        now = datetime.now()
        lastUpdated = max(graph.getLastUpdateTimes().values())
        updateDelta = now - lastUpdated

        if updateDelta > timedelta(seconds=30):
            exit(1)

        self.write("ok")

async def main():
    gu = GraphUpdater(graph)
    loop = asyncio.get_event_loop()
    ul = loop.create_task(gu.updateLoop())

    application = tornado.web.Application([
       (r"/", MainHandler),
       (r"/debug/?", DebugHandler),
       (r"/health/?", HealthHandler),
       (r"/station/?", StationHandler),
       (r"/station/([^/]*)/?", StationNameHandler),
       (r"/station/([^/]*)/([^/]*)/?", StationNamePlatHandler),
    ])

    port = None
    with open("/etc/metrolinkTimes/metrolinkTimes.conf") as conf_file:
        port = json.load(conf_file).get("port", 5000)

    server = HTTPServer(application)
    server.listen(port)

    await ul

if __name__ == '__main__':
    graph = TramGraph()
    io_loop = IOLoop.current()
    io_loop.run_sync(main)
