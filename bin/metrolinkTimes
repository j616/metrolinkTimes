#!/usr/bin/env python3
import json
from gevent import sleep, spawn
from datetime import datetime, timedelta
from sys import exit
import logging

import tornado.ioloop
import tornado.web
import tornado.wsgi
from tornado.web import RequestHandler
from tornado import escape
import gevent.wsgi

from metrolinkTimes.tfgmMetrolinksAPI import TFGMMetrolinksAPI
from metrolinkTimes.tramGraph import TramGraph

import gevent.monkey
gevent.monkey.patch_all()

logging.basicConfig(filename='/var/log/metrolinkTimes/metrolinkTimes.log',
                    format='%(asctime)s %(levelname)s %(pathname)s %(lineno)s '
                           '%(message)s',
                    level=logging.ERROR)


def dt_handler(obj):
    if isinstance(obj, datetime):
        return obj.isoformat()
    elif isinstance(obj, timedelta):
        return obj.total_seconds()

    raise TypeError


def json_encode(value):
    return json.dumps(
        value,
        ensure_ascii=False,
        indent=2,
        sort_keys=True,
        default=dt_handler)


escape.json_encode = json_encode


class GraphUpdater:
    def __init__(self, graph):
        self.api = TFGMMetrolinksAPI()
        self.graph = graph
        self.stationMappings = {
            "Ashton-under-Lyne": "Ashton-Under-Lyne",
            "Deansgate Castlefield": "Deansgate - Castlefield",
            "Deansgate": "Deansgate - Castlefield",
            "Ashton": "Ashton-Under-Lyne",
            "MCUK": "MediaCityUK",
            "Newton Heath": "Newton Heath and Moston",
            "Victoria Millgate Siding": "Victoria"
        }

    def update(self):
        data = self.api.getData()

        if data is None:
            # Internet down?
            return

        tramsVia = []

        for station in data:
            for platform in data[station]:
                nodeID = "{}_{}".format(station, platform)
                if nodeID not in self.graph.getNodes():
                    logging.error("ERROR: Unknonw platfrom {}".format(nodeID))
                    continue

                pidTramData = []
                message = None
                updateTime = None

                apiPID = data[station][platform][0]
                if not (apiPID["MessageBoard"].startswith("^F0")
                        or (apiPID["MessageBoard"] == "<no message>")):
                    message = apiPID["MessageBoard"]

                # This seems to be how flashing is encoded. We'll get rid of it
                if message is not None:
                    message = message.replace("^$", "")

                updateTime = datetime.strptime(
                    apiPID["LastUpdated"],
                    "%Y-%m-%dT%H:%M:%SZ")

                if self.graph.getLastUpdateTime(nodeID) == updateTime:
                    return

                for i in range(4):
                    if apiPID["Dest{}".format(i)] != "":
                        stationName = apiPID["Dest{}".format(i)]
                        # TODO: Shift this & station mappings to tramGraph
                        validDests = (list(self.graph.getStations())
                                      + [
                                            "Terminates Here",
                                            "See Tram Front",
                                            "Not in Service"])
                        viaName = None

                        if " via " in stationName:
                            splitName = stationName.split(" via ")
                            stationName = splitName[0]
                            viaName = splitName[1]
                        if stationName in self.stationMappings:
                            stationName = self.stationMappings[stationName]
                        if viaName in self.stationMappings:
                            viaName = self.stationMappings[viaName]
                            if viaName not in tramsVia:
                                tramsVia.append(viaName)
                        if stationName not in validDests:
                            logging.error(
                                "Unknown station {}".format(stationName))
                            continue
                        if (viaName is not None) and (
                          viaName not in validDests):
                            logging.error("Unknown station {}".format(viaName))
                            viaName = None

                        pidTramData.append({
                            "dest": stationName,
                            "via": viaName,
                            "carriages": apiPID["Carriages{}".format(i)],
                            "status": apiPID["Status{}".format(i)],
                            "wait": int(apiPID["Wait{}".format(i)])
                        })

                self.graph.updatePlatformPID(
                    nodeID,
                    pidTramData,
                    message,
                    updateTime)

        self.graph.decodePIDs()
        self.graph.clearOldDeparted()
        self.graph.locateDepartingTrams()
        self.graph.locateTramsAt()
        self.graph.clearNodePredictions()

        # We need to predict trams at definitively known locations first
        # so we can use these predictions to verify if trams are actually
        # starting at other stops
        self.graph.predictTramTimes(["tramsHere", "tramsDeparted"])
        self.graph.gatherTramPredictions(["tramsHere", "tramsDeparted"])

        # Use above predictions to check if trams are starting at other stops
        self.graph.locateApproachingTrams()
        self.graph.predictTramTimes(["tramsApproaching"])

        # Clear initial predictions, which may contain duplicated trams
        self.graph.clearNodePredictions()
        # Only de-duplicate now all positions are known and predictions made
        self.graph.deduplicateAllTrams()

        # Gather de-duplicated predictions
        self.graph.gatherTramPredictions(["tramsHere",
                                          "tramsDeparted",
                                          "tramsApproaching"])

        tramsAts = self.graph.getTramsAts()
        tramsAt = 0

        tramsArrivings = self.graph.getTramsArrivings()
        tramsArriving = 0

        tramsApproachings = self.graph.getTramsApproachings()
        tramsApproaching = 0

        for node in tramsAts:
            tramsAt = tramsAt + len(tramsAts[node])

        for node in tramsArrivings:
            tramsArriving = tramsArriving + len(tramsArrivings[node])

        for node in tramsApproachings:
            tramsApproaching = tramsApproaching + len(tramsApproachings[node])

        logging.info("Len nodes without average: {}".format(
            len(self.graph.nodesNoAvDwell())))
        logging.info("Len edges without average: {}".format(
            len(self.graph.edgesNoAvTrans())))
        logging.info("trams at stations: {}".format(tramsAt))
        logging.info("trams arriving at stations: {}".format(tramsArriving))
        logging.info("trams approaching stations: {}".format(tramsApproaching))
        logging.info("trams are going via {}".format(tramsVia))

    def updateLoop(self):
        while True:
            self.update()
            sleep(1)


class BaseHandler(RequestHandler):
    def set_default_headers(self, *args, **kwargs):
        origin = "*"
        with open("/etc/metrolinkTimes/metrolinkTimes.conf") as conf_file:
            origin = json.load(conf_file)["Access-Control-Allow-Origin"]
        self.set_header("Access-Control-Allow-Origin", origin)
        self.set_header("Access-Control-Allow-Headers", "x-requested-with")
        self.set_header("Access-Control-Allow-Methods", "GET, OPTIONS")


class MainHandler(BaseHandler):
    def get(self):
        self.write({"paths": [
            "debug/",
            "health/",
            "station/"
        ]})


class DebugHandler(BaseHandler):
    def get(self):
        here = graph.getTramsHeres()
        dep = graph.getTramsDeparteds()
        ret = {
            "missingAverages": {
                "platforms": graph.nodesNoAvDwell(),
                "edges": graph.edgesNoAvTrans()
            },
            "trams": {
                "here": {k: here[k] for k in here if here[k] != []},
                "departed": {k: dep[k] for k in dep if dep[k] != []}
            }
        }

        self.write(ret)


class StationHandler(BaseHandler):
    def get(self):
        ret = ["{}/".format(station) for station in graph.getStations()]
        self.write({"stations": ret})


class StationNameHandler(BaseHandler):
    def get(self, stationName):
        def getArg(name, default):
            arg = self.get_query_arguments(name)
            if arg == []:
                arg = default
            else:
                arg = arg[0]

            return arg

        if stationName not in graph.getStations():
            raise tornado.web.HTTPError(404)

        ret = {}

        if getArg("verbose", "false").lower() != "true":
            ret["platforms"] = [
                "{}/".format(platID) for platID in graph.getStationPlatforms(
                    stationName)]
        else:
            ret["platforms"] = {}
            for platID in graph.getStationPlatforms(stationName):
                nodeID = "{}_{}".format(stationName, platID)
                ret["platforms"][platID] = {
                    "updateTime": graph.getLastUpdateTime(nodeID),
                }

                if getArg("predictions", "true").lower() == "true":
                    predictions = graph.getNodePredictions()[nodeID]
                    if getArg("tramPredictions", "true").lower() == "false":
                        for tram in predictions:
                            del(tram["predictions"])
                    ret["platforms"][platID]["predictions"] = predictions
                    ret["platforms"][platID]["here"] = graph.getTramsHeres()[
                        nodeID]

                if getArg("message", "true").lower() == "true":
                    ret["platforms"][platID]["message"] = graph.getMessage(
                        nodeID)

                if getArg("meta", "false").lower() == "true":
                    dwellTimes = graph.getDwellTimes()[nodeID]
                    averageDwell = timedelta()
                    for dwellTime in dwellTimes:
                        averageDwell = averageDwell + dwellTime
                    if len(dwellTimes) > 0:
                        averageDwell = averageDwell/len(dwellTimes)
                    else:
                        averageDwell = None

                    pred = {}
                    for pNodeID in graph.getNodePreds(nodeID):
                        pred[pNodeID] = {
                            "transitTimes": graph.getTransit(pNodeID, nodeID)
                            }

                        (pred[pNodeID]["averageTransitTime"],
                            isDirectAverage) = graph.getAverageTransit(
                                pNodeID,
                                nodeID)

                    ret["platforms"][platID]["mapPos"] = {
                        "x": graph.getMapPos(nodeID)[0],
                        "y": graph.getMapPos(nodeID)[1]
                        }
                    ret["platforms"][platID]["dwellTimes"] = dwellTimes
                    ret["platforms"][platID]["averageDwellTime"] = averageDwell
                    ret["platforms"][platID]["predecessors"] = pred

            if getArg("departed", "false").lower() == "true":
                ret["platforms"][platID]["departed"] = (
                    graph.getTramsDeparteds()[nodeID])

        self.write(ret)


class StationNamePlatHandler(BaseHandler):
    def get(self, stationName, platID):
        def getArg(name, default):
            arg = self.get_query_arguments(name)
            if arg == []:
                arg = default
            else:
                arg = arg[0]

            return arg

        nodeID = "{}_{}".format(stationName, platID)
        if nodeID not in graph.getNodes():
            raise tornado.web.HTTPError(404)

        ret = {
            "updateTime": graph.getLastUpdateTime(nodeID),
        }

        if getArg("predictions", "true").lower() == "true":
            predictions = graph.getNodePredictions()[nodeID]
            if getArg("tramPredictions", "true").lower() == "false":
                for tram in predictions:
                    del(tram["predictions"])
            ret["predictions"] = predictions
            ret["here"] = graph.getTramsHeres()[nodeID]

        if getArg("message", "true").lower() == "true":
            ret["message"] = graph.getMessage(nodeID)

        if getArg("meta", "false").lower() == "true":
            dwellTimes = graph.getDwellTimes()[nodeID]
            averageDwell = timedelta()
            for dwellTime in dwellTimes:
                averageDwell = averageDwell + dwellTime
            if len(dwellTimes) > 0:
                averageDwell = averageDwell/len(dwellTimes)
            else:
                averageDwell = None

            pred = {}
            for pNodeID in graph.getNodePreds(nodeID):
                pred[pNodeID] = {
                    "transitTimes": graph.getTransit(pNodeID, nodeID)
                    }

                (pred[pNodeID]["averageTransitTime"],
                    isDirectAverage) = graph.getAverageTransit(pNodeID, nodeID)

            ret["mapPos"] = {
                "x": graph.getMapPos(nodeID)[0],
                "y": graph.getMapPos(nodeID)[1]
                }
            ret["dwellTimes"] = dwellTimes
            ret["averageDwellTime"] = averageDwell
            ret["predecessors"] = pred

        if getArg("departed", "false").lower() == "true":
            ret["departed"] = graph.getTramsDeparteds()[nodeID]

        self.write(ret)


class HealthHandler(BaseHandler):
    def get(self):
        now = datetime.now()
        lastUpdated = max(graph.getLastUpdateTimes().values())
        updateDelta = now - lastUpdated

        if updateDelta > timedelta(seconds=30):
            raise tornado.web.HTTPError(500)

        self.write("ok")


graph = TramGraph()
gu = GraphUpdater(graph)
spawn(gu.updateLoop).link_exception(lambda *args: exit("updateLoop died"))


application = tornado.wsgi.WSGIApplication([
   (r"/", MainHandler),
   (r"/debug/?", DebugHandler),
   (r"/health/?", HealthHandler),
   (r"/station/?", StationHandler),
   (r"/station/([^/]*)/?", StationNameHandler),
   (r"/station/([^/]*)/([^/]*)/?", StationNamePlatHandler),
])

port = None
with open("/etc/metrolinkTimes/metrolinkTimes.conf") as conf_file:
    port = json.load(conf_file).get("port", 5000)
server = gevent.wsgi.WSGIServer(('', port), application)
server.serve_forever()
